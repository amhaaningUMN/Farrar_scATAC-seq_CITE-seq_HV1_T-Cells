#!/usr/bin/env Rscript

rm(list = ls(all.names = TRUE))

set.seed(20)

options(
    rlang_backtrace_on_error = "full",
    error = rlang::entrace,
    menu.graphics = FALSE,
    repos = c("CRAN" = "https://mirror.las.iastate.edu/CRAN"),
    mc.cores = as.integer(system("[ ! -z ${THREADS+x} ] && echo ${THREADS} || echo 1", intern = TRUE))
)

curr_threads <- getOption("mc.cores")
if (curr_threads < 1 | is.null(curr_threads)) {stop("Error: The bash THREADS variable is less than 1 or null.")}
print(paste0("number of threads: ", curr_threads))



#######################################################################
# Load R packages
#######################################################################


library(toddr)
library(tidyverse)
library(glue)
library(gtools)



#######################################################################
# Script parameters
#######################################################################



proj <- "cd4_hv1_nilotinib_pdl1_il10_citeseq_20231201"
prefix <- "014_"
out <- glue("{prefix}tcr_clonotypes")
group <- "farrarm"
proj_dir <- glue("/home/{group}/shared/riss/knut0297/{proj}")
out_dir <- glue("{proj_dir}/code_out/{out}")


if (!dir.exists(glue("{out_dir}"))) {
    dir.create(glue("{out_dir}"), recursive = TRUE)
}
setwd(glue("{out_dir}"))




#######################################################################
# Analysis
#######################################################################


# ---------------------------------------------------------------------
# Get sample sheet
# ---------------------------------------------------------------------


samples <- readRDS(glue("{proj_dir}/code_out/010_samples/010_samples.rds"))
curr_tcr_dir <- Sys.glob(glue("{proj_dir}/code_out/013_count_tcr/*/outs"))



# ---------------------------------------------------------------------
# Get clonotypes
# ---------------------------------------------------------------------


# Clonotypes from cellranger
clonotypes <- read_csv(glue("{curr_tcr_dir}/clonotypes.csv"), col_types = cols(.default = "c")) %>%
    purrr::modify_at(vars(frequency, proportion), as.numeric)



# ---------------------------------------------------------------------
# Get contig annotations
# ---------------------------------------------------------------------


# https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/output/overview
# https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/output/annotation


# The filtered data contains only productive and high_confidence rows, making the following unnecessary
# dplyr::filter(productive == "true" & high_confidence == "true") %>%



# Question: What does the "productive" column mean in the contig_annotations.csv file generated by cellranger vdj?
# Answer: The "productive" column in all_contig_annotations.csv (or filtered_contig_annotations.csv) identifies
# contigs that are predicted to generate functional proteins. For a contig to be marked as productive, it must be V-J
# spanning with a start codon in the leader region. The contig must also have a detectable CDR3 region in frame
# with the start codon, and be free of stop codons in the V-J spanning region.
# TRUE == CDR3 is present and meets criteria above.
# FALSE == CDR3 is present, but there is a problem with it (premature stop, or too long).
# NONE == CDR3 is not present


# There is only one VDJ library (however, barcodes can be linked to different original sample HTOs)
contigs <- read_csv(glue("{curr_tcr_dir}/filtered_contig_annotations.csv"), col_types = cols(.default = "c")) %>%
    # Sometimes the raw file has "NA" values for the raw_clonotype_id -- remove these before downstream processing
    tidyr::drop_na(raw_clonotype_id) %>%
    purrr::modify_at(vars(reads, umis, length), as.numeric) %>%
    dplyr::mutate(barcode = str_remove(barcode, "-1$")) %>%
    purrr::modify_if(is.character, factor)



# ---------------------------------------------------------------------
# Any exactly duplicated CDR3 amino acid or nt sequences?
# ---------------------------------------------------------------------



# Are there any exactly duplicated "cdr3s_aa" sequences across all possible clonotypes?
dups_cdr3s_aa <- clonotypes %>%
    group_by(cdr3s_aa) %>%
    add_tally() %>%
    filter(n > 1) %>%
    arrange(desc(n))

write_tsv(dups_cdr3s_aa, glue("{prefix}raw_clonotypes_with_identical_cdr3s_aa.txt"))

# Are there any exactly duplicated "cdr3s_nt" sequences across all possible clonotypes?
dups_cdr3s_nt <- clonotypes %>%
    group_by(cdr3s_nt) %>%
    add_tally() %>%
    filter(n > 1) %>%
    arrange(desc(n))

write_tsv(dups_cdr3s_nt, glue("{prefix}raw_clonotypes_with_identical_cdr3s_nt.txt"))


# ---------------------------------------------------------------------
# Amino acid based clonotyping
# ---------------------------------------------------------------------
# Is there an easy way to see which, if any, cells have the same TRB + TRA contigs, either within or between samples?
# Yes, any GEMs/cells with the same "clonotype_id_cdr3aa" had the same CDR3 amino acid seqs for any/all TRA or TRB chains.
# The same is true at the CDR3 nt level: "clonotype_id_cdr3nt".

# Use the cellranger derived clonotypes (i.e. "raw_clonotype_id") as the original unique clonotype id. Across those raw clonotypes, find
# any clonotypes that have exactly the same "cdr3s_aa" or "cdr3s_nt" sequences. If there are multiple "raw_clonotype_id"s that
# have the same CDR3 seqs, combine them into new groups labeled with the same "clonotype_id_cdr3aa" or "clonotype_id_cdr3nt" value.

out <- toddr::add_nt_and_aa_clonotypes(list(clonotypes, contigs))

clonotypes2 <- out[[1]]
contigs2 <- out[[2]]


saveRDS(clonotypes2, glue("{prefix}clonotypes.rds"))
write_tsv(clonotypes2, glue("{prefix}clonotypes.txt"))


saveRDS(contigs2, glue("{prefix}contigs.rds"))
write_tsv(contigs2, glue("{prefix}contigs.txt"))



# ---------------------------------------------------------------------
# Unique aa clonotypes
# ---------------------------------------------------------------------

# Get a list of only the unique CDR3aa clonotypes and seqs
clonotype_id_cdr3aa_unique <- clonotypes2 %>%
    dplyr::select(clonotype_id_cdr3aa, cdr3s_aa) %>%
    distinct() %>%
    arrange(order(gtools::mixedorder(clonotype_id_cdr3aa)))


# Get a list of only the unique CDR3nt clonotypes and seqs
clonotype_id_cdr3nt_unique <- clonotypes2 %>%
    dplyr::select(clonotype_id_cdr3nt, cdr3s_nt) %>%
    distinct() %>%
    arrange(order(gtools::mixedorder(clonotype_id_cdr3nt)))


saveRDS(clonotype_id_cdr3aa_unique, glue("{prefix}clonotype_id_cdr3aa_unique.rds"))
write_tsv(clonotype_id_cdr3aa_unique, glue("{prefix}clonotype_id_cdr3aa_unique.txt"))

saveRDS(clonotype_id_cdr3nt_unique, glue("{prefix}clonotype_id_cdr3nt_unique.rds"))
write_tsv(clonotype_id_cdr3nt_unique, glue("{prefix}clonotype_id_cdr3nt_unique.txt"))







#######################################################################
# Save session info
#######################################################################


toddr::write_session_info(glue("{out_dir}/{prefix}"))
